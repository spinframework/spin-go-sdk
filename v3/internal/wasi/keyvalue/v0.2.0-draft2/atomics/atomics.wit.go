// Code generated by wit-bindgen-go. DO NOT EDIT.

// Package atomics represents the imported interface "wasi:keyvalue/atomics@0.2.0-draft2".
//
// A keyvalue interface that provides atomic operations.
//
// Atomic operations are single, indivisible operations. When a fault causes an atomic
// operation to
// fail, it will appear to the invoker of the atomic operation that the action either
// completed
// successfully or did nothing at all.
//
// Please note that this interface is bare functions that take a reference to a bucket.
// This is to
// get around the current lack of a way to "extend" a resource with additional methods
// inside of
// wit. Future version of the interface will instead extend these methods on the base
// `bucket`
// resource.
package atomics

import (
	"github.com/spinframework/spin-go-sdk/v3/internal/wasi/keyvalue/v0.2.0-draft2/store"
	"go.bytecodealliance.org/cm"
)

// Bucket represents the imported type alias "wasi:keyvalue/atomics@0.2.0-draft2#bucket".
//
// See [store.Bucket] for more information.
type Bucket = store.Bucket

// Error represents the type alias "wasi:keyvalue/atomics@0.2.0-draft2#error".
//
// See [store.Error] for more information.
type Error = store.Error

// Cas represents the imported resource "wasi:keyvalue/atomics@0.2.0-draft2#cas".
//
// A handle to a CAS (compare-and-swap) operation.
//
//	resource cas
type Cas cm.Resource

// ResourceDrop represents the imported resource-drop for resource "cas".
//
// Drops a resource handle.
//
//go:nosplit
func (self Cas) ResourceDrop() {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_CasResourceDrop((uint32)(self0))
	return
}

// CasNew represents the imported static function "new".
//
// Construct a new CAS operation. Implementors can map the underlying functionality
// (transactions, versions, etc) as desired.
//
//	new: static func(bucket: borrow<bucket>, key: string) -> result<cas, error>
//
//go:nosplit
func CasNew(bucket Bucket, key string) (result cm.Result[ErrorShape, Cas, Error]) {
	bucket0 := cm.Reinterpret[uint32](bucket)
	key0, key1 := cm.LowerString(key)
	wasmimport_CasNew((uint32)(bucket0), (*uint8)(key0), (uint32)(key1), &result)
	return
}

// Current represents the imported method "current".
//
// Get the current value of the key (if it exists). This allows for avoiding reads
// if all
// that is needed to ensure the atomicity of the operation
//
//	current: func() -> result<option<list<u8>>, error>
//
//go:nosplit
func (self Cas) Current() (result cm.Result[OptionListU8Shape, cm.Option[cm.List[uint8]], Error]) {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_CasCurrent((uint32)(self0), &result)
	return
}

// CasError represents the imported variant "wasi:keyvalue/atomics@0.2.0-draft2#cas-error".
//
// The error returned by a CAS operation
//
//	variant cas-error {
//		store-error(error),
//		cas-failed(cas),
//	}
type CasError cm.Variant[uint8, ErrorShape, Error]

// CasErrorStoreError returns a [CasError] of case "store-error".
//
// A store error occurred when performing the operation
func CasErrorStoreError(data Error) CasError {
	return cm.New[CasError](0, data)
}

// StoreError returns a non-nil *[Error] if [CasError] represents the variant case "store-error".
func (self *CasError) StoreError() *Error {
	return cm.Case[Error](self, 0)
}

// CasErrorCasFailed returns a [CasError] of case "cas-failed".
//
// The CAS operation failed because the value was too old. This returns a new CAS
// handle
// for easy retries. Implementors MUST return a CAS handle that has been updated to
// the
// latest version or transaction.
func CasErrorCasFailed(data Cas) CasError {
	return cm.New[CasError](1, data)
}

// CasFailed returns a non-nil *[Cas] if [CasError] represents the variant case "cas-failed".
func (self *CasError) CasFailed() *Cas {
	return cm.Case[Cas](self, 1)
}

var _CasErrorStrings = [2]string{
	"store-error",
	"cas-failed",
}

// String implements [fmt.Stringer], returning the variant case name of v.
func (v CasError) String() string {
	return _CasErrorStrings[v.Tag()]
}

// Increment represents the imported function "increment".
//
// Atomically increment the value associated with the key in the store by the given
// delta. It
// returns the new value.
//
// If the key does not exist in the store, it creates a new key-value pair with the
// value set
// to the given delta.
//
// If any other error occurs, it returns an `Err(error)`.
//
//	increment: func(bucket: borrow<bucket>, key: string, delta: s64) -> result<s64,
//	error>
//
//go:nosplit
func Increment(bucket Bucket, key string, delta int64) (result cm.Result[ErrorShape, int64, Error]) {
	bucket0 := cm.Reinterpret[uint32](bucket)
	key0, key1 := cm.LowerString(key)
	delta0 := (uint64)(delta)
	wasmimport_Increment((uint32)(bucket0), (*uint8)(key0), (uint32)(key1), (uint64)(delta0), &result)
	return
}

// Swap represents the imported function "swap".
//
// Perform the swap on a CAS operation. This consumes the CAS handle and returns an
// error if
// the CAS operation failed.
//
//	swap: func(cas: cas, value: list<u8>) -> result<_, cas-error>
//
//go:nosplit
func Swap(cas Cas, value cm.List[uint8]) (result cm.Result[CasError, struct{}, CasError]) {
	cas0 := cm.Reinterpret[uint32](cas)
	value0, value1 := cm.LowerList(value)
	wasmimport_Swap((uint32)(cas0), (*uint8)(value0), (uint32)(value1), &result)
	return
}
